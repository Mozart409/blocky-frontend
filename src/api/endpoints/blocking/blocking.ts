/**
 * Generated by orval v8.1.0 ðŸº
 * Do not edit manually.
 * blocky API
 * # Blocky
Blocky is a DNS proxy and ad-blocker for the local network written in Go with following features:
## Features
- **Blocking** - Blocking of DNS queries with external lists (Ad-block, malware) and allowlisting

  - Definition of allow/denylists per client group (Kids, Smart home devices, etc.)
  - Periodical reload of external allow/denylists
  - Regex support
  - Blocking of request domain, response CNAME (deep CNAME inspection) and response IP addresses (against IP lists)

- **Advanced DNS configuration** - not just an ad-blocker

  - Custom DNS resolution for certain domain names
  - Conditional forwarding to external DNS server
  - Upstream resolvers can be defined per client group

- **Performance** - Improves speed and performance in your network

  - Customizable caching of DNS answers for queries -> improves DNS resolution speed and reduces amount of external DNS
    queries
  - Prefetching and caching of often used queries
  - Using multiple external resolver simultaneously
  - Low memory footprint

- **Various Protocols** - Supports modern DNS protocols

  - DNS over UDP and TCP
  - DNS over HTTPS (aka DoH)
  - DNS over TLS (aka DoT)

- **Security and Privacy** - Secure communication

  - Supports modern DNS extensions: DNSSEC, eDNS, ...
  - Free configurable blocking lists - no hidden filtering etc.
  - Provides DoH Endpoint
  - Uses random upstream resolvers from the configuration - increases your privacy through the distribution of your DNS
    traffic over multiple provider
  - Blocky does **NOT** collect any user data, telemetry, statistics etc.

- **Integration** - various integration

  - [Prometheus](https://prometheus.io/) metrics
  - Prepared [Grafana](https://grafana.com/) dashboards (Prometheus and database)
  - Logging of DNS queries per day / per client in CSV format or MySQL/MariaDB/PostgreSQL/Timescale database - easy to
    analyze
  - Various REST API endpoints
  - CLI tool

- **Simple configuration** - single or multiple configuration files in YAML format

  - Simple to maintain
  - Simple to backup

- **Simple installation/configuration** - blocky was designed for simple installation

  - Stateless (no database, no temporary files)
  - Docker image with Multi-arch support
  - Single binary
  - Supports x86-64 and ARM architectures -> runs fine on Raspberry PI
  - Community supported Helm chart for k8s deployment

## Quick start
You can jump to [Installation](https://0xerr0r.github.io/blocky/installation/) chapter in the documentation.
## Full documentation
You can find full documentation and configuration examples at: [https://0xERR0R.github.io/blocky/](https://0xERR0R.github.io/blocky/)
 * OpenAPI spec version: 1.0
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  ApiBlockingStatus,
  DisableBlockingParams
} from '../../schemas';





/**
 * disable the blocking status
 * @summary Disable blocking
 */
export const disableBlocking = (
    params?: DisableBlockingParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/blocking/disable`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }




export const getDisableBlockingQueryKey = (params?: DisableBlockingParams,) => {
    return [
    `/api/blocking/disable`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getDisableBlockingQueryOptions = <TData = Awaited<ReturnType<typeof disableBlocking>>, TError = AxiosError<string>>(params?: DisableBlockingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof disableBlocking>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDisableBlockingQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof disableBlocking>>> = ({ signal }) => disableBlocking(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof disableBlocking>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DisableBlockingQueryResult = NonNullable<Awaited<ReturnType<typeof disableBlocking>>>
export type DisableBlockingQueryError = AxiosError<string>


export function useDisableBlocking<TData = Awaited<ReturnType<typeof disableBlocking>>, TError = AxiosError<string>>(
 params: undefined |  DisableBlockingParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof disableBlocking>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof disableBlocking>>,
          TError,
          Awaited<ReturnType<typeof disableBlocking>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDisableBlocking<TData = Awaited<ReturnType<typeof disableBlocking>>, TError = AxiosError<string>>(
 params?: DisableBlockingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof disableBlocking>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof disableBlocking>>,
          TError,
          Awaited<ReturnType<typeof disableBlocking>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDisableBlocking<TData = Awaited<ReturnType<typeof disableBlocking>>, TError = AxiosError<string>>(
 params?: DisableBlockingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof disableBlocking>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Disable blocking
 */

export function useDisableBlocking<TData = Awaited<ReturnType<typeof disableBlocking>>, TError = AxiosError<string>>(
 params?: DisableBlockingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof disableBlocking>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDisableBlockingQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * enable the blocking status
 * @summary Enable blocking
 */
export const enableBlocking = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.get(
      `/api/blocking/enable`,options
    );
  }




export const getEnableBlockingQueryKey = () => {
    return [
    `/api/blocking/enable`
    ] as const;
    }

    
export const getEnableBlockingQueryOptions = <TData = Awaited<ReturnType<typeof enableBlocking>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof enableBlocking>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEnableBlockingQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof enableBlocking>>> = ({ signal }) => enableBlocking({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof enableBlocking>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EnableBlockingQueryResult = NonNullable<Awaited<ReturnType<typeof enableBlocking>>>
export type EnableBlockingQueryError = AxiosError<unknown>


export function useEnableBlocking<TData = Awaited<ReturnType<typeof enableBlocking>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof enableBlocking>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof enableBlocking>>,
          TError,
          Awaited<ReturnType<typeof enableBlocking>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEnableBlocking<TData = Awaited<ReturnType<typeof enableBlocking>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof enableBlocking>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof enableBlocking>>,
          TError,
          Awaited<ReturnType<typeof enableBlocking>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEnableBlocking<TData = Awaited<ReturnType<typeof enableBlocking>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof enableBlocking>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Enable blocking
 */

export function useEnableBlocking<TData = Awaited<ReturnType<typeof enableBlocking>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof enableBlocking>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEnableBlockingQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * get current blocking status
 * @summary Blocking status
 */
export const blockingStatus = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiBlockingStatus>> => {
    
    
    return axios.get(
      `/api/blocking/status`,options
    );
  }




export const getBlockingStatusQueryKey = () => {
    return [
    `/api/blocking/status`
    ] as const;
    }

    
export const getBlockingStatusQueryOptions = <TData = Awaited<ReturnType<typeof blockingStatus>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof blockingStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBlockingStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof blockingStatus>>> = ({ signal }) => blockingStatus({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof blockingStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type BlockingStatusQueryResult = NonNullable<Awaited<ReturnType<typeof blockingStatus>>>
export type BlockingStatusQueryError = AxiosError<unknown>


export function useBlockingStatus<TData = Awaited<ReturnType<typeof blockingStatus>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof blockingStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof blockingStatus>>,
          TError,
          Awaited<ReturnType<typeof blockingStatus>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBlockingStatus<TData = Awaited<ReturnType<typeof blockingStatus>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof blockingStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof blockingStatus>>,
          TError,
          Awaited<ReturnType<typeof blockingStatus>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useBlockingStatus<TData = Awaited<ReturnType<typeof blockingStatus>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof blockingStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Blocking status
 */

export function useBlockingStatus<TData = Awaited<ReturnType<typeof blockingStatus>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof blockingStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBlockingStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




